// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: order.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (
    "order_id",
    "client_id",
    "trading_acct",
    "exchange_code",
    "product_code",
    "instrument_code",
    "order_side",
    "order_status",
    "order_type",
    "order_qty",
    "order_price",
    "time_inforce",
    "trading_session_id",
    "expire_date",
    "exec_qty",
    "exec_price",
    "cash",
    "Initial_margin",
    "exposure",
    "est_cost_to_close",
    "order_time",
    "underlying_code",
    "open_close",
    "put_or_call",
    "contract_size",
    "created_at",
    "updated_at"
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27
)
RETURNING order_id, client_id, trading_acct, product_code, exchange_code, instrument_code, order_side, order_status, order_type, order_qty, order_price, time_inforce, trading_session_id, expire_date, exec_qty, exec_price, cash, "Initial_margin", exposure, est_cost_to_close, order_time, underlying_code, open_close, put_or_call, contract_size, created_at, updated_at
`

type CreateOrderParams struct {
	OrderID          string             `json:"order_id"`
	ClientID         string             `json:"client_id"`
	TradingAcct      string             `json:"trading_acct"`
	ExchangeCode     string             `json:"exchange_code"`
	ProductCode      string             `json:"product_code"`
	InstrumentCode   string             `json:"instrument_code"`
	OrderSide        int32              `json:"order_side"`
	OrderStatus      int32              `json:"order_status"`
	OrderType        int32              `json:"order_type"`
	OrderQty         pgtype.Numeric     `json:"order_qty"`
	OrderPrice       pgtype.Numeric     `json:"order_price"`
	TimeInforce      pgtype.Int4        `json:"time_inforce"`
	TradingSessionID pgtype.Text        `json:"trading_session_id"`
	ExpireDate       pgtype.Date        `json:"expire_date"`
	ExecQty          pgtype.Numeric     `json:"exec_qty"`
	ExecPrice        pgtype.Numeric     `json:"exec_price"`
	Cash             pgtype.Numeric     `json:"cash"`
	InitialMargin    pgtype.Numeric     `json:"Initial_margin"`
	Exposure         pgtype.Numeric     `json:"exposure"`
	EstCostToClose   pgtype.Numeric     `json:"est_cost_to_close"`
	OrderTime        pgtype.Timestamptz `json:"order_time"`
	UnderlyingCode   pgtype.Text        `json:"underlying_code"`
	OpenClose        int32              `json:"open_close"`
	PutOrCall        pgtype.Int4        `json:"put_or_call"`
	ContractSize     pgtype.Numeric     `json:"contract_size"`
	CreatedAt        time.Time          `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.OrderID,
		arg.ClientID,
		arg.TradingAcct,
		arg.ExchangeCode,
		arg.ProductCode,
		arg.InstrumentCode,
		arg.OrderSide,
		arg.OrderStatus,
		arg.OrderType,
		arg.OrderQty,
		arg.OrderPrice,
		arg.TimeInforce,
		arg.TradingSessionID,
		arg.ExpireDate,
		arg.ExecQty,
		arg.ExecPrice,
		arg.Cash,
		arg.InitialMargin,
		arg.Exposure,
		arg.EstCostToClose,
		arg.OrderTime,
		arg.UnderlyingCode,
		arg.OpenClose,
		arg.PutOrCall,
		arg.ContractSize,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.ClientID,
		&i.TradingAcct,
		&i.ProductCode,
		&i.ExchangeCode,
		&i.InstrumentCode,
		&i.OrderSide,
		&i.OrderStatus,
		&i.OrderType,
		&i.OrderQty,
		&i.OrderPrice,
		&i.TimeInforce,
		&i.TradingSessionID,
		&i.ExpireDate,
		&i.ExecQty,
		&i.ExecPrice,
		&i.Cash,
		&i.InitialMargin,
		&i.Exposure,
		&i.EstCostToClose,
		&i.OrderTime,
		&i.UnderlyingCode,
		&i.OpenClose,
		&i.PutOrCall,
		&i.ContractSize,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM orders
WHERE "order_id" = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, orderID string) error {
	_, err := q.db.Exec(ctx, deleteOrder, orderID)
	return err
}

const getOrder = `-- name: GetOrder :one
SELECT order_id, client_id, trading_acct, product_code, exchange_code, instrument_code, order_side, order_status, order_type, order_qty, order_price, time_inforce, trading_session_id, expire_date, exec_qty, exec_price, cash, "Initial_margin", exposure, est_cost_to_close, order_time, underlying_code, open_close, put_or_call, contract_size, created_at, updated_at
FROM orders
WHERE "order_id" = $1
LIMIT 1
`

func (q *Queries) GetOrder(ctx context.Context, orderID string) (Order, error) {
	row := q.db.QueryRow(ctx, getOrder, orderID)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.ClientID,
		&i.TradingAcct,
		&i.ProductCode,
		&i.ExchangeCode,
		&i.InstrumentCode,
		&i.OrderSide,
		&i.OrderStatus,
		&i.OrderType,
		&i.OrderQty,
		&i.OrderPrice,
		&i.TimeInforce,
		&i.TradingSessionID,
		&i.ExpireDate,
		&i.ExecQty,
		&i.ExecPrice,
		&i.Cash,
		&i.InitialMargin,
		&i.Exposure,
		&i.EstCostToClose,
		&i.OrderTime,
		&i.UnderlyingCode,
		&i.OpenClose,
		&i.PutOrCall,
		&i.ContractSize,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderForUpdate = `-- name: GetOrderForUpdate :one
SELECT order_id, client_id, trading_acct, product_code, exchange_code, instrument_code, order_side, order_status, order_type, order_qty, order_price, time_inforce, trading_session_id, expire_date, exec_qty, exec_price, cash, "Initial_margin", exposure, est_cost_to_close, order_time, underlying_code, open_close, put_or_call, contract_size, created_at, updated_at
FROM orders
WHERE "order_id" = $1
LIMIT 1
FOR NO KEY UPDATE
`

func (q *Queries) GetOrderForUpdate(ctx context.Context, orderID string) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderForUpdate, orderID)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.ClientID,
		&i.TradingAcct,
		&i.ProductCode,
		&i.ExchangeCode,
		&i.InstrumentCode,
		&i.OrderSide,
		&i.OrderStatus,
		&i.OrderType,
		&i.OrderQty,
		&i.OrderPrice,
		&i.TimeInforce,
		&i.TradingSessionID,
		&i.ExpireDate,
		&i.ExecQty,
		&i.ExecPrice,
		&i.Cash,
		&i.InitialMargin,
		&i.Exposure,
		&i.EstCostToClose,
		&i.OrderTime,
		&i.UnderlyingCode,
		&i.OpenClose,
		&i.PutOrCall,
		&i.ContractSize,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listOrders = `-- name: ListOrders :many
SELECT order_id, client_id, trading_acct, product_code, exchange_code, instrument_code, order_side, order_status, order_type, order_qty, order_price, time_inforce, trading_session_id, expire_date, exec_qty, exec_price, cash, "Initial_margin", exposure, est_cost_to_close, order_time, underlying_code, open_close, put_or_call, contract_size, created_at, updated_at
FROM orders
WHERE "client_id" = $1
ORDER BY "order_time"
LIMIT $2
OFFSET $3
`

type ListOrdersParams struct {
	ClientID string `json:"client_id"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) ListOrders(ctx context.Context, arg ListOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrders, arg.ClientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.OrderID,
			&i.ClientID,
			&i.TradingAcct,
			&i.ProductCode,
			&i.ExchangeCode,
			&i.InstrumentCode,
			&i.OrderSide,
			&i.OrderStatus,
			&i.OrderType,
			&i.OrderQty,
			&i.OrderPrice,
			&i.TimeInforce,
			&i.TradingSessionID,
			&i.ExpireDate,
			&i.ExecQty,
			&i.ExecPrice,
			&i.Cash,
			&i.InitialMargin,
			&i.Exposure,
			&i.EstCostToClose,
			&i.OrderTime,
			&i.UnderlyingCode,
			&i.OpenClose,
			&i.PutOrCall,
			&i.ContractSize,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE orders
SET "order_qty" = $2,
    "exec_qty" = $3
WHERE "order_id" = $1
RETURNING order_id, client_id, trading_acct, product_code, exchange_code, instrument_code, order_side, order_status, order_type, order_qty, order_price, time_inforce, trading_session_id, expire_date, exec_qty, exec_price, cash, "Initial_margin", exposure, est_cost_to_close, order_time, underlying_code, open_close, put_or_call, contract_size, created_at, updated_at
`

type UpdateOrderParams struct {
	OrderID  string         `json:"order_id"`
	OrderQty pgtype.Numeric `json:"order_qty"`
	ExecQty  pgtype.Numeric `json:"exec_qty"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, updateOrder, arg.OrderID, arg.OrderQty, arg.ExecQty)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.ClientID,
		&i.TradingAcct,
		&i.ProductCode,
		&i.ExchangeCode,
		&i.InstrumentCode,
		&i.OrderSide,
		&i.OrderStatus,
		&i.OrderType,
		&i.OrderQty,
		&i.OrderPrice,
		&i.TimeInforce,
		&i.TradingSessionID,
		&i.ExpireDate,
		&i.ExecQty,
		&i.ExecPrice,
		&i.Cash,
		&i.InitialMargin,
		&i.Exposure,
		&i.EstCostToClose,
		&i.OrderTime,
		&i.UnderlyingCode,
		&i.OpenClose,
		&i.PutOrCall,
		&i.ContractSize,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
