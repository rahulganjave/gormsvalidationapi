// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: order.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders
    (
    order_id,
    client_id,
    trading_acct,
    exchange,
    product,
    instrument,
    side,
    status,
    order_type,
    order_qty,
    order_price,
    time_inforce,
    trading_session_id,
    expire_date,
    exec_qty,
    exec_price,
    cash,
    im,
    exposure,
    est_cost_to_close,
    order_time
    )
VALUES
    (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21
)
RETURNING order_id, client_id, trading_acct, exchange, product, instrument, side, status, order_type, order_qty, order_price, time_inforce, trading_session_id, expire_date, exec_qty, exec_price, cash, im, exposure, est_cost_to_close, order_time, created_at
`

type CreateOrderParams struct {
	OrderID          string             `json:"order_id"`
	ClientID         string             `json:"client_id"`
	TradingAcct      string             `json:"trading_acct"`
	Exchange         string             `json:"exchange"`
	Product          string             `json:"product"`
	Instrument       string             `json:"instrument"`
	Side             pgtype.Text        `json:"side"`
	Status           pgtype.Text        `json:"status"`
	OrderType        pgtype.Text        `json:"order_type"`
	OrderQty         pgtype.Numeric     `json:"order_qty"`
	OrderPrice       pgtype.Numeric     `json:"order_price"`
	TimeInforce      pgtype.Text        `json:"time_inforce"`
	TradingSessionID pgtype.Text        `json:"trading_session_id"`
	ExpireDate       pgtype.Date        `json:"expire_date"`
	ExecQty          pgtype.Numeric     `json:"exec_qty"`
	ExecPrice        pgtype.Numeric     `json:"exec_price"`
	Cash             pgtype.Numeric     `json:"cash"`
	Im               pgtype.Numeric     `json:"im"`
	Exposure         pgtype.Numeric     `json:"exposure"`
	EstCostToClose   pgtype.Numeric     `json:"est_cost_to_close"`
	OrderTime        pgtype.Timestamptz `json:"order_time"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.OrderID,
		arg.ClientID,
		arg.TradingAcct,
		arg.Exchange,
		arg.Product,
		arg.Instrument,
		arg.Side,
		arg.Status,
		arg.OrderType,
		arg.OrderQty,
		arg.OrderPrice,
		arg.TimeInforce,
		arg.TradingSessionID,
		arg.ExpireDate,
		arg.ExecQty,
		arg.ExecPrice,
		arg.Cash,
		arg.Im,
		arg.Exposure,
		arg.EstCostToClose,
		arg.OrderTime,
	)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.ClientID,
		&i.TradingAcct,
		&i.Exchange,
		&i.Product,
		&i.Instrument,
		&i.Side,
		&i.Status,
		&i.OrderType,
		&i.OrderQty,
		&i.OrderPrice,
		&i.TimeInforce,
		&i.TradingSessionID,
		&i.ExpireDate,
		&i.ExecQty,
		&i.ExecPrice,
		&i.Cash,
		&i.Im,
		&i.Exposure,
		&i.EstCostToClose,
		&i.OrderTime,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOrder = `-- name: DeleteOrder :exec
DELETE FROM orders
WHERE order_id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, orderID string) error {
	_, err := q.db.Exec(ctx, deleteOrder, orderID)
	return err
}

const getOrder = `-- name: GetOrder :one
SELECT order_id, client_id, trading_acct, exchange, product, instrument, side, status, order_type, order_qty, order_price, time_inforce, trading_session_id, expire_date, exec_qty, exec_price, cash, im, exposure, est_cost_to_close, order_time, created_at
FROM orders
WHERE order_id = $1
LIMIT 1
`

func (q *Queries) GetOrder(ctx context.Context, orderID string) (Order, error) {
	row := q.db.QueryRow(ctx, getOrder, orderID)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.ClientID,
		&i.TradingAcct,
		&i.Exchange,
		&i.Product,
		&i.Instrument,
		&i.Side,
		&i.Status,
		&i.OrderType,
		&i.OrderQty,
		&i.OrderPrice,
		&i.TimeInforce,
		&i.TradingSessionID,
		&i.ExpireDate,
		&i.ExecQty,
		&i.ExecPrice,
		&i.Cash,
		&i.Im,
		&i.Exposure,
		&i.EstCostToClose,
		&i.OrderTime,
		&i.CreatedAt,
	)
	return i, err
}

const getOrdersForUpdate = `-- name: GetOrdersForUpdate :one
/*SELECT *
FROM orders
WHERE order_id = $1
LIMIT 1
FOR NO KEY
UPDATE;*/

/*SELECT *
FROM orders
WHERE order_id = $1
ORDER BY id
LIMIT $2
OFFSET
$3;*/

UPDATE orders
SET order_qty = $2,
exec_qty = $3
WHERE order_id = $1
RETURNING order_id, client_id, trading_acct, exchange, product, instrument, side, status, order_type, order_qty, order_price, time_inforce, trading_session_id, expire_date, exec_qty, exec_price, cash, im, exposure, est_cost_to_close, order_time, created_at
`

type GetOrdersForUpdateParams struct {
	OrderID  string         `json:"order_id"`
	OrderQty pgtype.Numeric `json:"order_qty"`
	ExecQty  pgtype.Numeric `json:"exec_qty"`
}

func (q *Queries) GetOrdersForUpdate(ctx context.Context, arg GetOrdersForUpdateParams) (Order, error) {
	row := q.db.QueryRow(ctx, getOrdersForUpdate, arg.OrderID, arg.OrderQty, arg.ExecQty)
	var i Order
	err := row.Scan(
		&i.OrderID,
		&i.ClientID,
		&i.TradingAcct,
		&i.Exchange,
		&i.Product,
		&i.Instrument,
		&i.Side,
		&i.Status,
		&i.OrderType,
		&i.OrderQty,
		&i.OrderPrice,
		&i.TimeInforce,
		&i.TradingSessionID,
		&i.ExpireDate,
		&i.ExecQty,
		&i.ExecPrice,
		&i.Cash,
		&i.Im,
		&i.Exposure,
		&i.EstCostToClose,
		&i.OrderTime,
		&i.CreatedAt,
	)
	return i, err
}
