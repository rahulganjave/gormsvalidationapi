// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: instrument.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createInstrument = `-- name: CreateInstrument :one
INSERT INTO instruments (
    "product_code",
    "exchange_code",
    "instrument_code",
    "underlying_code",
    "instrument_desc",
    "maturity_monthyear",
    "maturity_day",
    "put_or_call",
    "strike_price",
    "symbol",
    "symbol_sfx",
    "cusip",
    "isin",
    "ric",
    "sedol",
    "blpsyn",
    "cficode",
    "price_code",
    "effective_date",
    "minqty",
    "sector",
    "contract_size",
    "corporate_action",
    "trading_session_id",
    "trading_curr",
    "price_dec",
    "handl_inst",
    "tick_id",
    "market_slippage",
    "ref_px",
    "ref_px_type",
    "tplusone",
    "created_at",
    "updated_at"
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34
)
RETURNING product_code, exchange_code, instrument_code, underlying_code, instrument_desc, maturity_monthyear, maturity_day, put_or_call, strike_price, symbol, symbol_sfx, cusip, isin, ric, sedol, blpsyn, cficode, price_code, effective_date, minqty, sector, contract_size, corporate_action, trading_session_id, trading_curr, price_dec, handl_inst, tick_id, market_slippage, ref_px, ref_px_type, tplusone, created_at, updated_at
`

type CreateInstrumentParams struct {
	ProductCode       string             `json:"product_code"`
	ExchangeCode      string             `json:"exchange_code"`
	InstrumentCode    string             `json:"instrument_code"`
	UnderlyingCode    pgtype.Text        `json:"underlying_code"`
	InstrumentDesc    pgtype.Text        `json:"instrument_desc"`
	MaturityMonthyear pgtype.Text        `json:"maturity_monthyear"`
	MaturityDay       pgtype.Text        `json:"maturity_day"`
	PutOrCall         pgtype.Text        `json:"put_or_call"`
	StrikePrice       pgtype.Numeric     `json:"strike_price"`
	Symbol            pgtype.Text        `json:"symbol"`
	SymbolSfx         pgtype.Text        `json:"symbol_sfx"`
	Cusip             pgtype.Text        `json:"cusip"`
	Isin              pgtype.Text        `json:"isin"`
	Ric               pgtype.Text        `json:"ric"`
	Sedol             pgtype.Text        `json:"sedol"`
	Blpsyn            pgtype.Text        `json:"blpsyn"`
	Cficode           pgtype.Text        `json:"cficode"`
	PriceCode         pgtype.Text        `json:"price_code"`
	EffectiveDate     pgtype.Timestamp   `json:"effective_date"`
	Minqty            int32              `json:"minqty"`
	Sector            pgtype.Text        `json:"sector"`
	ContractSize      pgtype.Numeric     `json:"contract_size"`
	CorporateAction   pgtype.Text        `json:"corporate_action"`
	TradingSessionID  pgtype.Text        `json:"trading_session_id"`
	TradingCurr       pgtype.Text        `json:"trading_curr"`
	PriceDec          pgtype.Numeric     `json:"price_dec"`
	HandlInst         pgtype.Text        `json:"handl_inst"`
	TickID            int32              `json:"tick_id"`
	MarketSlippage    pgtype.Numeric     `json:"market_slippage"`
	RefPx             pgtype.Numeric     `json:"ref_px"`
	RefPxType         int16              `json:"ref_px_type"`
	Tplusone          pgtype.Int4        `json:"tplusone"`
	CreatedAt         time.Time          `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateInstrument(ctx context.Context, arg CreateInstrumentParams) (Instrument, error) {
	row := q.db.QueryRow(ctx, createInstrument,
		arg.ProductCode,
		arg.ExchangeCode,
		arg.InstrumentCode,
		arg.UnderlyingCode,
		arg.InstrumentDesc,
		arg.MaturityMonthyear,
		arg.MaturityDay,
		arg.PutOrCall,
		arg.StrikePrice,
		arg.Symbol,
		arg.SymbolSfx,
		arg.Cusip,
		arg.Isin,
		arg.Ric,
		arg.Sedol,
		arg.Blpsyn,
		arg.Cficode,
		arg.PriceCode,
		arg.EffectiveDate,
		arg.Minqty,
		arg.Sector,
		arg.ContractSize,
		arg.CorporateAction,
		arg.TradingSessionID,
		arg.TradingCurr,
		arg.PriceDec,
		arg.HandlInst,
		arg.TickID,
		arg.MarketSlippage,
		arg.RefPx,
		arg.RefPxType,
		arg.Tplusone,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Instrument
	err := row.Scan(
		&i.ProductCode,
		&i.ExchangeCode,
		&i.InstrumentCode,
		&i.UnderlyingCode,
		&i.InstrumentDesc,
		&i.MaturityMonthyear,
		&i.MaturityDay,
		&i.PutOrCall,
		&i.StrikePrice,
		&i.Symbol,
		&i.SymbolSfx,
		&i.Cusip,
		&i.Isin,
		&i.Ric,
		&i.Sedol,
		&i.Blpsyn,
		&i.Cficode,
		&i.PriceCode,
		&i.EffectiveDate,
		&i.Minqty,
		&i.Sector,
		&i.ContractSize,
		&i.CorporateAction,
		&i.TradingSessionID,
		&i.TradingCurr,
		&i.PriceDec,
		&i.HandlInst,
		&i.TickID,
		&i.MarketSlippage,
		&i.RefPx,
		&i.RefPxType,
		&i.Tplusone,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteInstrument = `-- name: DeleteInstrument :exec
DELETE FROM instruments
WHERE "product_code" = $1 AND "exchange_code" = $2 AND "instrument_code" = $3
`

type DeleteInstrumentParams struct {
	ProductCode    string `json:"product_code"`
	ExchangeCode   string `json:"exchange_code"`
	InstrumentCode string `json:"instrument_code"`
}

func (q *Queries) DeleteInstrument(ctx context.Context, arg DeleteInstrumentParams) error {
	_, err := q.db.Exec(ctx, deleteInstrument, arg.ProductCode, arg.ExchangeCode, arg.InstrumentCode)
	return err
}

const getInstrument = `-- name: GetInstrument :one
SELECT product_code, exchange_code, instrument_code, underlying_code, instrument_desc, maturity_monthyear, maturity_day, put_or_call, strike_price, symbol, symbol_sfx, cusip, isin, ric, sedol, blpsyn, cficode, price_code, effective_date, minqty, sector, contract_size, corporate_action, trading_session_id, trading_curr, price_dec, handl_inst, tick_id, market_slippage, ref_px, ref_px_type, tplusone, created_at, updated_at
FROM instruments
WHERE "product_code" = $1 AND "exchange_code" = $2 AND "instrument_code" = $3
LIMIT 1
`

type GetInstrumentParams struct {
	ProductCode    string `json:"product_code"`
	ExchangeCode   string `json:"exchange_code"`
	InstrumentCode string `json:"instrument_code"`
}

func (q *Queries) GetInstrument(ctx context.Context, arg GetInstrumentParams) (Instrument, error) {
	row := q.db.QueryRow(ctx, getInstrument, arg.ProductCode, arg.ExchangeCode, arg.InstrumentCode)
	var i Instrument
	err := row.Scan(
		&i.ProductCode,
		&i.ExchangeCode,
		&i.InstrumentCode,
		&i.UnderlyingCode,
		&i.InstrumentDesc,
		&i.MaturityMonthyear,
		&i.MaturityDay,
		&i.PutOrCall,
		&i.StrikePrice,
		&i.Symbol,
		&i.SymbolSfx,
		&i.Cusip,
		&i.Isin,
		&i.Ric,
		&i.Sedol,
		&i.Blpsyn,
		&i.Cficode,
		&i.PriceCode,
		&i.EffectiveDate,
		&i.Minqty,
		&i.Sector,
		&i.ContractSize,
		&i.CorporateAction,
		&i.TradingSessionID,
		&i.TradingCurr,
		&i.PriceDec,
		&i.HandlInst,
		&i.TickID,
		&i.MarketSlippage,
		&i.RefPx,
		&i.RefPxType,
		&i.Tplusone,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInstrumentForUpdate = `-- name: GetInstrumentForUpdate :one
SELECT product_code, exchange_code, instrument_code, underlying_code, instrument_desc, maturity_monthyear, maturity_day, put_or_call, strike_price, symbol, symbol_sfx, cusip, isin, ric, sedol, blpsyn, cficode, price_code, effective_date, minqty, sector, contract_size, corporate_action, trading_session_id, trading_curr, price_dec, handl_inst, tick_id, market_slippage, ref_px, ref_px_type, tplusone, created_at, updated_at
FROM instruments
WHERE "product_code" = $1 AND "exchange_code" = $2 AND "instrument_code" = $3
LIMIT 1
FOR NO KEY UPDATE
`

type GetInstrumentForUpdateParams struct {
	ProductCode    string `json:"product_code"`
	ExchangeCode   string `json:"exchange_code"`
	InstrumentCode string `json:"instrument_code"`
}

func (q *Queries) GetInstrumentForUpdate(ctx context.Context, arg GetInstrumentForUpdateParams) (Instrument, error) {
	row := q.db.QueryRow(ctx, getInstrumentForUpdate, arg.ProductCode, arg.ExchangeCode, arg.InstrumentCode)
	var i Instrument
	err := row.Scan(
		&i.ProductCode,
		&i.ExchangeCode,
		&i.InstrumentCode,
		&i.UnderlyingCode,
		&i.InstrumentDesc,
		&i.MaturityMonthyear,
		&i.MaturityDay,
		&i.PutOrCall,
		&i.StrikePrice,
		&i.Symbol,
		&i.SymbolSfx,
		&i.Cusip,
		&i.Isin,
		&i.Ric,
		&i.Sedol,
		&i.Blpsyn,
		&i.Cficode,
		&i.PriceCode,
		&i.EffectiveDate,
		&i.Minqty,
		&i.Sector,
		&i.ContractSize,
		&i.CorporateAction,
		&i.TradingSessionID,
		&i.TradingCurr,
		&i.PriceDec,
		&i.HandlInst,
		&i.TickID,
		&i.MarketSlippage,
		&i.RefPx,
		&i.RefPxType,
		&i.Tplusone,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listInstruments = `-- name: ListInstruments :many
SELECT product_code, exchange_code, instrument_code, underlying_code, instrument_desc, maturity_monthyear, maturity_day, put_or_call, strike_price, symbol, symbol_sfx, cusip, isin, ric, sedol, blpsyn, cficode, price_code, effective_date, minqty, sector, contract_size, corporate_action, trading_session_id, trading_curr, price_dec, handl_inst, tick_id, market_slippage, ref_px, ref_px_type, tplusone, created_at, updated_at
FROM instruments
ORDER BY "product_code", "exchange_code", "instrument_code"
LIMIT $1
OFFSET $2
`

type ListInstrumentsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListInstruments(ctx context.Context, arg ListInstrumentsParams) ([]Instrument, error) {
	rows, err := q.db.Query(ctx, listInstruments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Instrument{}
	for rows.Next() {
		var i Instrument
		if err := rows.Scan(
			&i.ProductCode,
			&i.ExchangeCode,
			&i.InstrumentCode,
			&i.UnderlyingCode,
			&i.InstrumentDesc,
			&i.MaturityMonthyear,
			&i.MaturityDay,
			&i.PutOrCall,
			&i.StrikePrice,
			&i.Symbol,
			&i.SymbolSfx,
			&i.Cusip,
			&i.Isin,
			&i.Ric,
			&i.Sedol,
			&i.Blpsyn,
			&i.Cficode,
			&i.PriceCode,
			&i.EffectiveDate,
			&i.Minqty,
			&i.Sector,
			&i.ContractSize,
			&i.CorporateAction,
			&i.TradingSessionID,
			&i.TradingCurr,
			&i.PriceDec,
			&i.HandlInst,
			&i.TickID,
			&i.MarketSlippage,
			&i.RefPx,
			&i.RefPxType,
			&i.Tplusone,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInstrument = `-- name: UpdateInstrument :one
UPDATE instruments
SET "underlying_code" = $2,
    "instrument_desc" = $3,
    "maturity_monthyear" = $4,
    "maturity_day" = $5,
    "put_or_call" = $6,
    "strike_price" = $7,
    "symbol" = $8,
    "symbol_sfx" = $9,
    "cusip" = $10,
    "isin" = $11,
    "ric" = $12,
    "sedol" = $13,
    "blpsyn" = $14,
    "cficode" = $15,
    "price_code" = $16,
    "effective_date" = $17,
    "minqty" = $18,
    "sector" = $19,
    "contract_size" = $20,
    "corporate_action" = $21,
    "trading_session_id" = $22,
    "trading_curr" = $23,
    "price_dec" = $24,
    "handl_inst" = $25,
    "tick_id" = $26,
    "market_slippage" = $27,
    "ref_px" = $28,
    "ref_px_type" = $29,
    "tplusone" = $30,
    "updated_at" = NOW()
WHERE "product_code" = $1 AND "exchange_code" = $2 AND "instrument_code" = $3
RETURNING product_code, exchange_code, instrument_code, underlying_code, instrument_desc, maturity_monthyear, maturity_day, put_or_call, strike_price, symbol, symbol_sfx, cusip, isin, ric, sedol, blpsyn, cficode, price_code, effective_date, minqty, sector, contract_size, corporate_action, trading_session_id, trading_curr, price_dec, handl_inst, tick_id, market_slippage, ref_px, ref_px_type, tplusone, created_at, updated_at
`

type UpdateInstrumentParams struct {
	ProductCode       string           `json:"product_code"`
	UnderlyingCode    pgtype.Text      `json:"underlying_code"`
	InstrumentDesc    pgtype.Text      `json:"instrument_desc"`
	MaturityMonthyear pgtype.Text      `json:"maturity_monthyear"`
	MaturityDay       pgtype.Text      `json:"maturity_day"`
	PutOrCall         pgtype.Text      `json:"put_or_call"`
	StrikePrice       pgtype.Numeric   `json:"strike_price"`
	Symbol            pgtype.Text      `json:"symbol"`
	SymbolSfx         pgtype.Text      `json:"symbol_sfx"`
	Cusip             pgtype.Text      `json:"cusip"`
	Isin              pgtype.Text      `json:"isin"`
	Ric               pgtype.Text      `json:"ric"`
	Sedol             pgtype.Text      `json:"sedol"`
	Blpsyn            pgtype.Text      `json:"blpsyn"`
	Cficode           pgtype.Text      `json:"cficode"`
	PriceCode         pgtype.Text      `json:"price_code"`
	EffectiveDate     pgtype.Timestamp `json:"effective_date"`
	Minqty            int32            `json:"minqty"`
	Sector            pgtype.Text      `json:"sector"`
	ContractSize      pgtype.Numeric   `json:"contract_size"`
	CorporateAction   pgtype.Text      `json:"corporate_action"`
	TradingSessionID  pgtype.Text      `json:"trading_session_id"`
	TradingCurr       pgtype.Text      `json:"trading_curr"`
	PriceDec          pgtype.Numeric   `json:"price_dec"`
	HandlInst         pgtype.Text      `json:"handl_inst"`
	TickID            int32            `json:"tick_id"`
	MarketSlippage    pgtype.Numeric   `json:"market_slippage"`
	RefPx             pgtype.Numeric   `json:"ref_px"`
	RefPxType         int16            `json:"ref_px_type"`
	Tplusone          pgtype.Int4      `json:"tplusone"`
}

func (q *Queries) UpdateInstrument(ctx context.Context, arg UpdateInstrumentParams) (Instrument, error) {
	row := q.db.QueryRow(ctx, updateInstrument,
		arg.ProductCode,
		arg.UnderlyingCode,
		arg.InstrumentDesc,
		arg.MaturityMonthyear,
		arg.MaturityDay,
		arg.PutOrCall,
		arg.StrikePrice,
		arg.Symbol,
		arg.SymbolSfx,
		arg.Cusip,
		arg.Isin,
		arg.Ric,
		arg.Sedol,
		arg.Blpsyn,
		arg.Cficode,
		arg.PriceCode,
		arg.EffectiveDate,
		arg.Minqty,
		arg.Sector,
		arg.ContractSize,
		arg.CorporateAction,
		arg.TradingSessionID,
		arg.TradingCurr,
		arg.PriceDec,
		arg.HandlInst,
		arg.TickID,
		arg.MarketSlippage,
		arg.RefPx,
		arg.RefPxType,
		arg.Tplusone,
	)
	var i Instrument
	err := row.Scan(
		&i.ProductCode,
		&i.ExchangeCode,
		&i.InstrumentCode,
		&i.UnderlyingCode,
		&i.InstrumentDesc,
		&i.MaturityMonthyear,
		&i.MaturityDay,
		&i.PutOrCall,
		&i.StrikePrice,
		&i.Symbol,
		&i.SymbolSfx,
		&i.Cusip,
		&i.Isin,
		&i.Ric,
		&i.Sedol,
		&i.Blpsyn,
		&i.Cficode,
		&i.PriceCode,
		&i.EffectiveDate,
		&i.Minqty,
		&i.Sector,
		&i.ContractSize,
		&i.CorporateAction,
		&i.TradingSessionID,
		&i.TradingCurr,
		&i.PriceDec,
		&i.HandlInst,
		&i.TickID,
		&i.MarketSlippage,
		&i.RefPx,
		&i.RefPxType,
		&i.Tplusone,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
