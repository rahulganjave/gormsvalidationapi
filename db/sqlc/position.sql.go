// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: position.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPosition = `-- name: CreatePosition :one
INSERT INTO Positions
    (
    position_id,
    ref_position_id,
    trading_acct,
    client_id,
    product,
    exchange,
    instrument,
    side,
    status,
    position_type,
    settlement_status,
    calc_type,
    open_qty,
    open_px,
    closed_qty,
    closed_px,
    trading_curr,
    settle_curr,
    mark_price,
    mark_value,
    exchange_rate,
    unrealized_pl,
    realized_pl,
    mm_and_cash,
    collateral_haircut_ratio,
    collateral_haircut,
    open_date,
    closed_date,
    cost_to_close,
    trade_date,
    trading_session_id,
    underlying,
    open_close,
    put_or_call,
    contract_size
    )
VALUES
    (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34, $35
)
RETURNING position_id, ref_position_id, trading_acct, client_id, product, exchange, instrument, side, status, position_type, settlement_status, calc_type, open_qty, open_px, closed_qty, closed_px, trading_curr, settle_curr, mark_price, mark_value, exchange_rate, unrealized_pl, realized_pl, mm_and_cash, collateral_haircut_ratio, collateral_haircut, open_date, closed_date, cost_to_close, trade_date, trading_session_id, underlying, open_close, put_or_call, contract_size, created_at
`

type CreatePositionParams struct {
	PositionID             string             `json:"position_id"`
	RefPositionID          pgtype.Text        `json:"ref_position_id"`
	TradingAcct            string             `json:"trading_acct"`
	ClientID               string             `json:"client_id"`
	Product                string             `json:"product"`
	Exchange               string             `json:"exchange"`
	Instrument             string             `json:"instrument"`
	Side                   pgtype.Text        `json:"side"`
	Status                 pgtype.Text        `json:"status"`
	PositionType           pgtype.Text        `json:"position_type"`
	SettlementStatus       pgtype.Text        `json:"settlement_status"`
	CalcType               pgtype.Text        `json:"calc_type"`
	OpenQty                pgtype.Numeric     `json:"open_qty"`
	OpenPx                 pgtype.Numeric     `json:"open_px"`
	ClosedQty              pgtype.Numeric     `json:"closed_qty"`
	ClosedPx               pgtype.Numeric     `json:"closed_px"`
	TradingCurr            pgtype.Text        `json:"trading_curr"`
	SettleCurr             pgtype.Text        `json:"settle_curr"`
	MarkPrice              pgtype.Numeric     `json:"mark_price"`
	MarkValue              pgtype.Numeric     `json:"mark_value"`
	ExchangeRate           pgtype.Numeric     `json:"exchange_rate"`
	UnrealizedPl           pgtype.Numeric     `json:"unrealized_pl"`
	RealizedPl             pgtype.Numeric     `json:"realized_pl"`
	MmAndCash              pgtype.Numeric     `json:"mm_and_cash"`
	CollateralHaircutRatio pgtype.Numeric     `json:"collateral_haircut_ratio"`
	CollateralHaircut      pgtype.Numeric     `json:"collateral_haircut"`
	OpenDate               pgtype.Timestamptz `json:"open_date"`
	ClosedDate             pgtype.Timestamptz `json:"closed_date"`
	CostToClose            pgtype.Numeric     `json:"cost_to_close"`
	TradeDate              pgtype.Date        `json:"trade_date"`
	TradingSessionID       pgtype.Text        `json:"trading_session_id"`
	Underlying             pgtype.Text        `json:"underlying"`
	OpenClose              pgtype.Text        `json:"open_close"`
	PutOrCall              pgtype.Text        `json:"put_or_call"`
	ContractSize           pgtype.Numeric     `json:"contract_size"`
}

func (q *Queries) CreatePosition(ctx context.Context, arg CreatePositionParams) (Position, error) {
	row := q.db.QueryRow(ctx, createPosition,
		arg.PositionID,
		arg.RefPositionID,
		arg.TradingAcct,
		arg.ClientID,
		arg.Product,
		arg.Exchange,
		arg.Instrument,
		arg.Side,
		arg.Status,
		arg.PositionType,
		arg.SettlementStatus,
		arg.CalcType,
		arg.OpenQty,
		arg.OpenPx,
		arg.ClosedQty,
		arg.ClosedPx,
		arg.TradingCurr,
		arg.SettleCurr,
		arg.MarkPrice,
		arg.MarkValue,
		arg.ExchangeRate,
		arg.UnrealizedPl,
		arg.RealizedPl,
		arg.MmAndCash,
		arg.CollateralHaircutRatio,
		arg.CollateralHaircut,
		arg.OpenDate,
		arg.ClosedDate,
		arg.CostToClose,
		arg.TradeDate,
		arg.TradingSessionID,
		arg.Underlying,
		arg.OpenClose,
		arg.PutOrCall,
		arg.ContractSize,
	)
	var i Position
	err := row.Scan(
		&i.PositionID,
		&i.RefPositionID,
		&i.TradingAcct,
		&i.ClientID,
		&i.Product,
		&i.Exchange,
		&i.Instrument,
		&i.Side,
		&i.Status,
		&i.PositionType,
		&i.SettlementStatus,
		&i.CalcType,
		&i.OpenQty,
		&i.OpenPx,
		&i.ClosedQty,
		&i.ClosedPx,
		&i.TradingCurr,
		&i.SettleCurr,
		&i.MarkPrice,
		&i.MarkValue,
		&i.ExchangeRate,
		&i.UnrealizedPl,
		&i.RealizedPl,
		&i.MmAndCash,
		&i.CollateralHaircutRatio,
		&i.CollateralHaircut,
		&i.OpenDate,
		&i.ClosedDate,
		&i.CostToClose,
		&i.TradeDate,
		&i.TradingSessionID,
		&i.Underlying,
		&i.OpenClose,
		&i.PutOrCall,
		&i.ContractSize,
		&i.CreatedAt,
	)
	return i, err
}

const deletePosition = `-- name: DeletePosition :exec
DELETE FROM Positions
WHERE position_id = $1
`

func (q *Queries) DeletePosition(ctx context.Context, positionID string) error {
	_, err := q.db.Exec(ctx, deletePosition, positionID)
	return err
}

const getPosition = `-- name: GetPosition :one
SELECT position_id, ref_position_id, trading_acct, client_id, product, exchange, instrument, side, status, position_type, settlement_status, calc_type, open_qty, open_px, closed_qty, closed_px, trading_curr, settle_curr, mark_price, mark_value, exchange_rate, unrealized_pl, realized_pl, mm_and_cash, collateral_haircut_ratio, collateral_haircut, open_date, closed_date, cost_to_close, trade_date, trading_session_id, underlying, open_close, put_or_call, contract_size, created_at
FROM Positions
WHERE position_id = $1
LIMIT 1
`

func (q *Queries) GetPosition(ctx context.Context, positionID string) (Position, error) {
	row := q.db.QueryRow(ctx, getPosition, positionID)
	var i Position
	err := row.Scan(
		&i.PositionID,
		&i.RefPositionID,
		&i.TradingAcct,
		&i.ClientID,
		&i.Product,
		&i.Exchange,
		&i.Instrument,
		&i.Side,
		&i.Status,
		&i.PositionType,
		&i.SettlementStatus,
		&i.CalcType,
		&i.OpenQty,
		&i.OpenPx,
		&i.ClosedQty,
		&i.ClosedPx,
		&i.TradingCurr,
		&i.SettleCurr,
		&i.MarkPrice,
		&i.MarkValue,
		&i.ExchangeRate,
		&i.UnrealizedPl,
		&i.RealizedPl,
		&i.MmAndCash,
		&i.CollateralHaircutRatio,
		&i.CollateralHaircut,
		&i.OpenDate,
		&i.ClosedDate,
		&i.CostToClose,
		&i.TradeDate,
		&i.TradingSessionID,
		&i.Underlying,
		&i.OpenClose,
		&i.PutOrCall,
		&i.ContractSize,
		&i.CreatedAt,
	)
	return i, err
}

const getPositionsForUpdate = `-- name: GetPositionsForUpdate :one
SELECT position_id, ref_position_id, trading_acct, client_id, product, exchange, instrument, side, status, position_type, settlement_status, calc_type, open_qty, open_px, closed_qty, closed_px, trading_curr, settle_curr, mark_price, mark_value, exchange_rate, unrealized_pl, realized_pl, mm_and_cash, collateral_haircut_ratio, collateral_haircut, open_date, closed_date, cost_to_close, trade_date, trading_session_id, underlying, open_close, put_or_call, contract_size, created_at
FROM Positions
WHERE position_id = $1
LIMIT 1
FOR NO KEY
UPDATE
`

func (q *Queries) GetPositionsForUpdate(ctx context.Context, positionID string) (Position, error) {
	row := q.db.QueryRow(ctx, getPositionsForUpdate, positionID)
	var i Position
	err := row.Scan(
		&i.PositionID,
		&i.RefPositionID,
		&i.TradingAcct,
		&i.ClientID,
		&i.Product,
		&i.Exchange,
		&i.Instrument,
		&i.Side,
		&i.Status,
		&i.PositionType,
		&i.SettlementStatus,
		&i.CalcType,
		&i.OpenQty,
		&i.OpenPx,
		&i.ClosedQty,
		&i.ClosedPx,
		&i.TradingCurr,
		&i.SettleCurr,
		&i.MarkPrice,
		&i.MarkValue,
		&i.ExchangeRate,
		&i.UnrealizedPl,
		&i.RealizedPl,
		&i.MmAndCash,
		&i.CollateralHaircutRatio,
		&i.CollateralHaircut,
		&i.OpenDate,
		&i.ClosedDate,
		&i.CostToClose,
		&i.TradeDate,
		&i.TradingSessionID,
		&i.Underlying,
		&i.OpenClose,
		&i.PutOrCall,
		&i.ContractSize,
		&i.CreatedAt,
	)
	return i, err
}

const listPositions = `-- name: ListPositions :many
SELECT position_id, ref_position_id, trading_acct, client_id, product, exchange, instrument, side, status, position_type, settlement_status, calc_type, open_qty, open_px, closed_qty, closed_px, trading_curr, settle_curr, mark_price, mark_value, exchange_rate, unrealized_pl, realized_pl, mm_and_cash, collateral_haircut_ratio, collateral_haircut, open_date, closed_date, cost_to_close, trade_date, trading_session_id, underlying, open_close, put_or_call, contract_size, created_at
FROM Positions
WHERE position_id = $1
ORDER BY position_id
LIMIT $2
OFFSET
$3
`

type ListPositionsParams struct {
	PositionID string `json:"position_id"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

func (q *Queries) ListPositions(ctx context.Context, arg ListPositionsParams) ([]Position, error) {
	rows, err := q.db.Query(ctx, listPositions, arg.PositionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Position{}
	for rows.Next() {
		var i Position
		if err := rows.Scan(
			&i.PositionID,
			&i.RefPositionID,
			&i.TradingAcct,
			&i.ClientID,
			&i.Product,
			&i.Exchange,
			&i.Instrument,
			&i.Side,
			&i.Status,
			&i.PositionType,
			&i.SettlementStatus,
			&i.CalcType,
			&i.OpenQty,
			&i.OpenPx,
			&i.ClosedQty,
			&i.ClosedPx,
			&i.TradingCurr,
			&i.SettleCurr,
			&i.MarkPrice,
			&i.MarkValue,
			&i.ExchangeRate,
			&i.UnrealizedPl,
			&i.RealizedPl,
			&i.MmAndCash,
			&i.CollateralHaircutRatio,
			&i.CollateralHaircut,
			&i.OpenDate,
			&i.ClosedDate,
			&i.CostToClose,
			&i.TradeDate,
			&i.TradingSessionID,
			&i.Underlying,
			&i.OpenClose,
			&i.PutOrCall,
			&i.ContractSize,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePosition = `-- name: UpdatePosition :one
UPDATE Positions
SET open_qty = $2,
open_px = $3
WHERE position_id = $1
RETURNING position_id, ref_position_id, trading_acct, client_id, product, exchange, instrument, side, status, position_type, settlement_status, calc_type, open_qty, open_px, closed_qty, closed_px, trading_curr, settle_curr, mark_price, mark_value, exchange_rate, unrealized_pl, realized_pl, mm_and_cash, collateral_haircut_ratio, collateral_haircut, open_date, closed_date, cost_to_close, trade_date, trading_session_id, underlying, open_close, put_or_call, contract_size, created_at
`

type UpdatePositionParams struct {
	PositionID string         `json:"position_id"`
	OpenQty    pgtype.Numeric `json:"open_qty"`
	OpenPx     pgtype.Numeric `json:"open_px"`
}

func (q *Queries) UpdatePosition(ctx context.Context, arg UpdatePositionParams) (Position, error) {
	row := q.db.QueryRow(ctx, updatePosition, arg.PositionID, arg.OpenQty, arg.OpenPx)
	var i Position
	err := row.Scan(
		&i.PositionID,
		&i.RefPositionID,
		&i.TradingAcct,
		&i.ClientID,
		&i.Product,
		&i.Exchange,
		&i.Instrument,
		&i.Side,
		&i.Status,
		&i.PositionType,
		&i.SettlementStatus,
		&i.CalcType,
		&i.OpenQty,
		&i.OpenPx,
		&i.ClosedQty,
		&i.ClosedPx,
		&i.TradingCurr,
		&i.SettleCurr,
		&i.MarkPrice,
		&i.MarkValue,
		&i.ExchangeRate,
		&i.UnrealizedPl,
		&i.RealizedPl,
		&i.MmAndCash,
		&i.CollateralHaircutRatio,
		&i.CollateralHaircut,
		&i.OpenDate,
		&i.ClosedDate,
		&i.CostToClose,
		&i.TradeDate,
		&i.TradingSessionID,
		&i.Underlying,
		&i.OpenClose,
		&i.PutOrCall,
		&i.ContractSize,
		&i.CreatedAt,
	)
	return i, err
}
