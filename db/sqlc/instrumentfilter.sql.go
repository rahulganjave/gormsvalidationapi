// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: instrumentfilter.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createInstrumentfilter = `-- name: CreateInstrumentfilter :one
INSERT INTO instrumentfilter
    (
    product,
    exchange,
    instrument,
    underlying,
    filter,
    max_order_qty,
    max_order_price,
    max_order_value,
    buy_lmt,
    sell_lmt,
    exposure_factor,
    buy_exposure,
    sell_exposure,
    buy_qty_lmt,
    buy_qty_exposure,
    sell_qty_lmt,
    sell_qty_exposure,
    net_qty_lmt,
    net_qty_exposure,
    margin_type,
    im,
    mm,
    marginable_ratio,
    margin_curr,
    commission_type,
    commission,
    min_commission,
    commission_curr,
    authorized_order_type,
    trading_curr,
    price_code,
    ref_px,
    ref_px_type,
    contract_size
    )
VALUES
    (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34
)
RETURNING product, exchange, instrument, underlying, filter, max_order_qty, max_order_price, max_order_value, buy_lmt, sell_lmt, exposure_factor, buy_exposure, sell_exposure, buy_qty_lmt, buy_qty_exposure, sell_qty_lmt, sell_qty_exposure, net_qty_lmt, net_qty_exposure, margin_type, im, mm, marginable_ratio, margin_curr, commission_type, commission, min_commission, commission_curr, authorized_order_type, trading_curr, price_code, action_on_record, ref_px, ref_px_type, contract_size, created_at
`

type CreateInstrumentfilterParams struct {
	Product             string         `json:"product"`
	Exchange            string         `json:"exchange"`
	Instrument          string         `json:"instrument"`
	Underlying          pgtype.Text    `json:"underlying"`
	Filter              pgtype.Int4    `json:"filter"`
	MaxOrderQty         pgtype.Numeric `json:"max_order_qty"`
	MaxOrderPrice       pgtype.Numeric `json:"max_order_price"`
	MaxOrderValue       pgtype.Numeric `json:"max_order_value"`
	BuyLmt              pgtype.Numeric `json:"buy_lmt"`
	SellLmt             pgtype.Numeric `json:"sell_lmt"`
	ExposureFactor      pgtype.Numeric `json:"exposure_factor"`
	BuyExposure         pgtype.Numeric `json:"buy_exposure"`
	SellExposure        pgtype.Numeric `json:"sell_exposure"`
	BuyQtyLmt           pgtype.Numeric `json:"buy_qty_lmt"`
	BuyQtyExposure      pgtype.Numeric `json:"buy_qty_exposure"`
	SellQtyLmt          pgtype.Numeric `json:"sell_qty_lmt"`
	SellQtyExposure     pgtype.Numeric `json:"sell_qty_exposure"`
	NetQtyLmt           pgtype.Numeric `json:"net_qty_lmt"`
	NetQtyExposure      pgtype.Numeric `json:"net_qty_exposure"`
	MarginType          pgtype.Text    `json:"margin_type"`
	Im                  pgtype.Numeric `json:"im"`
	Mm                  pgtype.Numeric `json:"mm"`
	MarginableRatio     pgtype.Numeric `json:"marginable_ratio"`
	MarginCurr          pgtype.Text    `json:"margin_curr"`
	CommissionType      pgtype.Text    `json:"commission_type"`
	Commission          pgtype.Numeric `json:"commission"`
	MinCommission       pgtype.Numeric `json:"min_commission"`
	CommissionCurr      pgtype.Text    `json:"commission_curr"`
	AuthorizedOrderType pgtype.Int8    `json:"authorized_order_type"`
	TradingCurr         pgtype.Text    `json:"trading_curr"`
	PriceCode           pgtype.Text    `json:"price_code"`
	RefPx               pgtype.Numeric `json:"ref_px"`
	RefPxType           pgtype.Int2    `json:"ref_px_type"`
	ContractSize        pgtype.Numeric `json:"contract_size"`
}

func (q *Queries) CreateInstrumentfilter(ctx context.Context, arg CreateInstrumentfilterParams) (Instrumentfilter, error) {
	row := q.db.QueryRow(ctx, createInstrumentfilter,
		arg.Product,
		arg.Exchange,
		arg.Instrument,
		arg.Underlying,
		arg.Filter,
		arg.MaxOrderQty,
		arg.MaxOrderPrice,
		arg.MaxOrderValue,
		arg.BuyLmt,
		arg.SellLmt,
		arg.ExposureFactor,
		arg.BuyExposure,
		arg.SellExposure,
		arg.BuyQtyLmt,
		arg.BuyQtyExposure,
		arg.SellQtyLmt,
		arg.SellQtyExposure,
		arg.NetQtyLmt,
		arg.NetQtyExposure,
		arg.MarginType,
		arg.Im,
		arg.Mm,
		arg.MarginableRatio,
		arg.MarginCurr,
		arg.CommissionType,
		arg.Commission,
		arg.MinCommission,
		arg.CommissionCurr,
		arg.AuthorizedOrderType,
		arg.TradingCurr,
		arg.PriceCode,
		arg.RefPx,
		arg.RefPxType,
		arg.ContractSize,
	)
	var i Instrumentfilter
	err := row.Scan(
		&i.Product,
		&i.Exchange,
		&i.Instrument,
		&i.Underlying,
		&i.Filter,
		&i.MaxOrderQty,
		&i.MaxOrderPrice,
		&i.MaxOrderValue,
		&i.BuyLmt,
		&i.SellLmt,
		&i.ExposureFactor,
		&i.BuyExposure,
		&i.SellExposure,
		&i.BuyQtyLmt,
		&i.BuyQtyExposure,
		&i.SellQtyLmt,
		&i.SellQtyExposure,
		&i.NetQtyLmt,
		&i.NetQtyExposure,
		&i.MarginType,
		&i.Im,
		&i.Mm,
		&i.MarginableRatio,
		&i.MarginCurr,
		&i.CommissionType,
		&i.Commission,
		&i.MinCommission,
		&i.CommissionCurr,
		&i.AuthorizedOrderType,
		&i.TradingCurr,
		&i.PriceCode,
		&i.ActionOnRecord,
		&i.RefPx,
		&i.RefPxType,
		&i.ContractSize,
		&i.CreatedAt,
	)
	return i, err
}

const deleteInstrumentfilter = `-- name: DeleteInstrumentfilter :exec
DELETE FROM instrumentfilter
WHERE instrument = $1
AND exchange = $2
AND product = $3
`

type DeleteInstrumentfilterParams struct {
	Instrument string `json:"instrument"`
	Exchange   string `json:"exchange"`
	Product    string `json:"product"`
}

func (q *Queries) DeleteInstrumentfilter(ctx context.Context, arg DeleteInstrumentfilterParams) error {
	_, err := q.db.Exec(ctx, deleteInstrumentfilter, arg.Instrument, arg.Exchange, arg.Product)
	return err
}

const getInstrumentfilter = `-- name: GetInstrumentfilter :one
SELECT product, exchange, instrument, underlying, filter, max_order_qty, max_order_price, max_order_value, buy_lmt, sell_lmt, exposure_factor, buy_exposure, sell_exposure, buy_qty_lmt, buy_qty_exposure, sell_qty_lmt, sell_qty_exposure, net_qty_lmt, net_qty_exposure, margin_type, im, mm, marginable_ratio, margin_curr, commission_type, commission, min_commission, commission_curr, authorized_order_type, trading_curr, price_code, action_on_record, ref_px, ref_px_type, contract_size, created_at
FROM instrumentfilter
WHERE instrument = $1
AND exchange = $2
AND product = $3
LIMIT 1
`

type GetInstrumentfilterParams struct {
	Instrument string `json:"instrument"`
	Exchange   string `json:"exchange"`
	Product    string `json:"product"`
}

func (q *Queries) GetInstrumentfilter(ctx context.Context, arg GetInstrumentfilterParams) (Instrumentfilter, error) {
	row := q.db.QueryRow(ctx, getInstrumentfilter, arg.Instrument, arg.Exchange, arg.Product)
	var i Instrumentfilter
	err := row.Scan(
		&i.Product,
		&i.Exchange,
		&i.Instrument,
		&i.Underlying,
		&i.Filter,
		&i.MaxOrderQty,
		&i.MaxOrderPrice,
		&i.MaxOrderValue,
		&i.BuyLmt,
		&i.SellLmt,
		&i.ExposureFactor,
		&i.BuyExposure,
		&i.SellExposure,
		&i.BuyQtyLmt,
		&i.BuyQtyExposure,
		&i.SellQtyLmt,
		&i.SellQtyExposure,
		&i.NetQtyLmt,
		&i.NetQtyExposure,
		&i.MarginType,
		&i.Im,
		&i.Mm,
		&i.MarginableRatio,
		&i.MarginCurr,
		&i.CommissionType,
		&i.Commission,
		&i.MinCommission,
		&i.CommissionCurr,
		&i.AuthorizedOrderType,
		&i.TradingCurr,
		&i.PriceCode,
		&i.ActionOnRecord,
		&i.RefPx,
		&i.RefPxType,
		&i.ContractSize,
		&i.CreatedAt,
	)
	return i, err
}

const getInstrumentfilterForUpdate = `-- name: GetInstrumentfilterForUpdate :one
SELECT product, exchange, instrument, underlying, filter, max_order_qty, max_order_price, max_order_value, buy_lmt, sell_lmt, exposure_factor, buy_exposure, sell_exposure, buy_qty_lmt, buy_qty_exposure, sell_qty_lmt, sell_qty_exposure, net_qty_lmt, net_qty_exposure, margin_type, im, mm, marginable_ratio, margin_curr, commission_type, commission, min_commission, commission_curr, authorized_order_type, trading_curr, price_code, action_on_record, ref_px, ref_px_type, contract_size, created_at
FROM instrumentfilter
WHERE instrument = $1
AND exchange = $2
AND product = $3
LIMIT 1
FOR NO KEY
UPDATE
`

type GetInstrumentfilterForUpdateParams struct {
	Instrument string `json:"instrument"`
	Exchange   string `json:"exchange"`
	Product    string `json:"product"`
}

func (q *Queries) GetInstrumentfilterForUpdate(ctx context.Context, arg GetInstrumentfilterForUpdateParams) (Instrumentfilter, error) {
	row := q.db.QueryRow(ctx, getInstrumentfilterForUpdate, arg.Instrument, arg.Exchange, arg.Product)
	var i Instrumentfilter
	err := row.Scan(
		&i.Product,
		&i.Exchange,
		&i.Instrument,
		&i.Underlying,
		&i.Filter,
		&i.MaxOrderQty,
		&i.MaxOrderPrice,
		&i.MaxOrderValue,
		&i.BuyLmt,
		&i.SellLmt,
		&i.ExposureFactor,
		&i.BuyExposure,
		&i.SellExposure,
		&i.BuyQtyLmt,
		&i.BuyQtyExposure,
		&i.SellQtyLmt,
		&i.SellQtyExposure,
		&i.NetQtyLmt,
		&i.NetQtyExposure,
		&i.MarginType,
		&i.Im,
		&i.Mm,
		&i.MarginableRatio,
		&i.MarginCurr,
		&i.CommissionType,
		&i.Commission,
		&i.MinCommission,
		&i.CommissionCurr,
		&i.AuthorizedOrderType,
		&i.TradingCurr,
		&i.PriceCode,
		&i.ActionOnRecord,
		&i.RefPx,
		&i.RefPxType,
		&i.ContractSize,
		&i.CreatedAt,
	)
	return i, err
}

const listInstrumentfilter = `-- name: ListInstrumentfilter :many
SELECT product, exchange, instrument, underlying, filter, max_order_qty, max_order_price, max_order_value, buy_lmt, sell_lmt, exposure_factor, buy_exposure, sell_exposure, buy_qty_lmt, buy_qty_exposure, sell_qty_lmt, sell_qty_exposure, net_qty_lmt, net_qty_exposure, margin_type, im, mm, marginable_ratio, margin_curr, commission_type, commission, min_commission, commission_curr, authorized_order_type, trading_curr, price_code, action_on_record, ref_px, ref_px_type, contract_size, created_at
FROM instrumentfilter
WHERE instrument = $1
AND exchange = $2
AND product = $3
LIMIT $4
OFFSET
$5
`

type ListInstrumentfilterParams struct {
	Instrument string `json:"instrument"`
	Exchange   string `json:"exchange"`
	Product    string `json:"product"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

func (q *Queries) ListInstrumentfilter(ctx context.Context, arg ListInstrumentfilterParams) ([]Instrumentfilter, error) {
	rows, err := q.db.Query(ctx, listInstrumentfilter,
		arg.Instrument,
		arg.Exchange,
		arg.Product,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Instrumentfilter{}
	for rows.Next() {
		var i Instrumentfilter
		if err := rows.Scan(
			&i.Product,
			&i.Exchange,
			&i.Instrument,
			&i.Underlying,
			&i.Filter,
			&i.MaxOrderQty,
			&i.MaxOrderPrice,
			&i.MaxOrderValue,
			&i.BuyLmt,
			&i.SellLmt,
			&i.ExposureFactor,
			&i.BuyExposure,
			&i.SellExposure,
			&i.BuyQtyLmt,
			&i.BuyQtyExposure,
			&i.SellQtyLmt,
			&i.SellQtyExposure,
			&i.NetQtyLmt,
			&i.NetQtyExposure,
			&i.MarginType,
			&i.Im,
			&i.Mm,
			&i.MarginableRatio,
			&i.MarginCurr,
			&i.CommissionType,
			&i.Commission,
			&i.MinCommission,
			&i.CommissionCurr,
			&i.AuthorizedOrderType,
			&i.TradingCurr,
			&i.PriceCode,
			&i.ActionOnRecord,
			&i.RefPx,
			&i.RefPxType,
			&i.ContractSize,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInstrumentfilter = `-- name: UpdateInstrumentfilter :one
UPDATE instrumentfilter
SET buy_exposure = $4,
sell_exposure = $5
WHERE instrument = $1
AND exchange = $2
AND product = $3
RETURNING product, exchange, instrument, underlying, filter, max_order_qty, max_order_price, max_order_value, buy_lmt, sell_lmt, exposure_factor, buy_exposure, sell_exposure, buy_qty_lmt, buy_qty_exposure, sell_qty_lmt, sell_qty_exposure, net_qty_lmt, net_qty_exposure, margin_type, im, mm, marginable_ratio, margin_curr, commission_type, commission, min_commission, commission_curr, authorized_order_type, trading_curr, price_code, action_on_record, ref_px, ref_px_type, contract_size, created_at
`

type UpdateInstrumentfilterParams struct {
	Instrument   string         `json:"instrument"`
	Exchange     string         `json:"exchange"`
	Product      string         `json:"product"`
	BuyExposure  pgtype.Numeric `json:"buy_exposure"`
	SellExposure pgtype.Numeric `json:"sell_exposure"`
}

func (q *Queries) UpdateInstrumentfilter(ctx context.Context, arg UpdateInstrumentfilterParams) (Instrumentfilter, error) {
	row := q.db.QueryRow(ctx, updateInstrumentfilter,
		arg.Instrument,
		arg.Exchange,
		arg.Product,
		arg.BuyExposure,
		arg.SellExposure,
	)
	var i Instrumentfilter
	err := row.Scan(
		&i.Product,
		&i.Exchange,
		&i.Instrument,
		&i.Underlying,
		&i.Filter,
		&i.MaxOrderQty,
		&i.MaxOrderPrice,
		&i.MaxOrderValue,
		&i.BuyLmt,
		&i.SellLmt,
		&i.ExposureFactor,
		&i.BuyExposure,
		&i.SellExposure,
		&i.BuyQtyLmt,
		&i.BuyQtyExposure,
		&i.SellQtyLmt,
		&i.SellQtyExposure,
		&i.NetQtyLmt,
		&i.NetQtyExposure,
		&i.MarginType,
		&i.Im,
		&i.Mm,
		&i.MarginableRatio,
		&i.MarginCurr,
		&i.CommissionType,
		&i.Commission,
		&i.MinCommission,
		&i.CommissionCurr,
		&i.AuthorizedOrderType,
		&i.TradingCurr,
		&i.PriceCode,
		&i.ActionOnRecord,
		&i.RefPx,
		&i.RefPxType,
		&i.ContractSize,
		&i.CreatedAt,
	)
	return i, err
}
